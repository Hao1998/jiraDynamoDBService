service: jira-processor

# Simplified - no stage variables needed for single environment
custom:
  # Fixed names for single prod environment
  tableName: critical-issues
  queueName: jira-critical-issues
  functionName: jira-processor

provider:
  name: aws
  runtime: nodejs18.x
  stage: prod  # Fixed to prod
  region: us-east-1

  environment:
    NODE_ENV: production
    DYNAMODB_TABLE: ${self:custom.tableName}
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1

  # Cost-optimized IAM (minimal permissions)
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:BatchWriteItem
          Resource: !GetAtt CriticalIssuesTable.Arn

  provider:
    # ... existing config
    deploymentBucket:
      name: jira-processor-prod-serverlessdeploymentbucket  # Custom name
      serverSideEncryption: AES256
      blockPublicAccess: true

# MOVED: Package configuration to top level (not under provider)
package:
  patterns:
    - '!node_modules/aws-sdk/**'  # Already included in Lambda runtime
    - '!tests/**'
    - '!*.test.js'
    - '!coverage/**'
    - '!README.md'
    - '!.git/**'
    - '!.github/**'

functions:
  processCriticalIssues:
    name: ${self:custom.functionName}
    handler: index.handler

    # Cost optimization settings
    memorySize: 256        # Minimum for cost (128MB often too slow)
    timeout: 60           # Shorter timeout = lower cost
    reservedConcurrency: 5 # Prevent runaway costs

    # Environment variables
    environment:
      LOG_LEVEL: WARN  # Reduce CloudWatch logs cost

    events:
      - sqs:
          arn: !GetAtt CriticalIssuesQueue.Arn
          batchSize: 10  # Process more per invocation = fewer invocations = lower cost
          maximumBatchingWindow: 5
          functionResponseType: ReportBatchItemFailures

resources:
  Resources:
    # Cost-optimized DynamoDB
    CriticalIssuesTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        BillingMode: PAY_PER_REQUEST  # No fixed costs, pay only for usage

        AttributeDefinitions:
          - AttributeName: issueId
            AttributeType: S

        KeySchema:
          - AttributeName: issueId
            KeyType: HASH

        # Cost optimization: TTL for automatic cleanup
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true

        Tags:
          - Key: Project
            Value: personal
          - Key: Environment
            Value: prod

    # Cost-optimized SQS
    CriticalIssuesQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.queueName}
        VisibilityTimeoutSeconds: 360  # 6x Lambda timeout
        MessageRetentionPeriod: 345600  # 4 days (shorter = lower cost)

        RedrivePolicy:
          deadLetterTargetArn: !GetAtt CriticalIssuesDLQ.Arn
          maxReceiveCount: 3

    # Dead Letter Queue (essential for production)
    CriticalIssuesDLQ:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.queueName}-dlq
        MessageRetentionPeriod: 345600  # 4 days

    # Cost-optimized CloudWatch Logs (shorter retention)
    ProcessorLogGroup:
      Type: AWS::Logs::LogGroup
      Properties:
        LogGroupName: /aws/lambda/${self:custom.functionName}
        RetentionInDays: 7  # Short retention = lower cost

    # Essential alarm only (no dashboard to save costs)
    ProcessorErrorAlarm:
      Type: AWS::CloudWatch::Alarm
      Properties:
        AlarmName: jira-processor-errors
        AlarmDescription: "Lambda function errors"
        MetricName: Errors
        Namespace: AWS/Lambda
        Statistic: Sum
        Period: 300
        EvaluationPeriods: 1
        Threshold: 5
        ComparisonOperator: GreaterThanOrEqualToThreshold
        Dimensions:
          - Name: FunctionName
            Value: ${self:custom.functionName}

  Outputs:
    QueueUrl:
      Description: SQS Queue URL for sending messages
      Value: !Ref CriticalIssuesQueue